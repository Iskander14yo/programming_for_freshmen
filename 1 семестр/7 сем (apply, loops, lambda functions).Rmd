---
title: "7 семинар"
output:
  html_document:
    df_print: paged
  pdf_document: default
  html_notebook: default
---

Инициализируем данные, с которыми будем работать.

```{r}
Sys.setenv(LANG = 'en')
arr = 1:9
mat = matrix(arr, nrow = 3) 
print(mat)
```

Загрузим также magrittr, который позволит пайпить (так будет проще принтить в консоль):

```{r}
require(magrittr)
```

## \*apply() functions

В основном для работы с данными нам потребуются 3 функции типа apply: собственно сам apply(), lapply() и sapply(), что в принципе то же самое, что и lapply. Как их использовать:

Пусть мы хотим посчитать *среднее* каждой *строки* матрицы `mat`. В таком случае мы можем сделать следующее:

```{r}
print(mat)
apply(X = mat, MARGIN = 1, FUN = mean)
```

Здесь Х - наши данные, MARGIN - измерение, по которому мы хотим идти, FUN - функция, которую мы применяем по отношению к данным.\
Если бы мы хотели написать аналогичный код без apply, то мы бы написали что-то следующее:

```{r}
means = c()
for (row in 1:nrow(mat)) means = c(means, mean(mat[row,]))
print(means)
```

Мы получили такой же ответ, но что в нашем втором решении не очень хорошо:\
а) мы использовали дополнительный массив (means). Если мы будем дальше его использовать, то ок, но если он нужен только для промежуточных вычислений, то мы просто забиваем нашу оперативную память и добавляем в глобальную среду объекты, которые нам в дальнейшем будут не нужны.\
б) мы писали достаточно широкий (или длинный, если его разделить на строки) цикл for, который мы сможем с помощью apply написать более компактно. Помните, что читаемость кода - тоже важная опция ваших проектов и скриптов.

Если бы мы хотели получить среднее по столбцам, то в таком случае мы прокидываем в MARGIN уже 2:

```{r}
apply(mat, MARGIN = 2, mean)
```

То есть, подытоживая, apply рассматривает вашу матрицу (или датафрейм), как либо набор строк, либо набор столбцов, к каждым из которых он применяет функцию, которую вы указали в FUN. Если ваш MARGIN = 1:2, то вы будете применять FUN *поэлементно* к вашей матрице. Попробуйте сначала представить, что делает apply далее, не заглядывая в консоль:

```{r}
apply(mat, 1:2, mean)
```

Действительно, мы просто получили изначальную матрицу, потому что `mean(number) = number`.

С apply разобрались, пошли к **lapply**. lapply применяет к каждому элементу массива функцию, после чего возвращает вам список.\
Допустим нам нужно каждый элемент массива (вектора или матрицы) увеличить на 1. Тогда мы можем сделать следующее:

```{r}
f = function(i) {
  return(i+1)
}
lapply(arr[1:5], FUN = f)
```

Как и ожидалось, вывод является списком (поскольку я ввел только первые 5 элементов arr, то мы и получили 5-элементный список), в котором каждый элемент больше на 1 соответствующих элементов в arr.

Мы получили список, и, хотя это может быть полезно, зачастую нам хотелось бы получать из вектора вектор, а не list. В таком случае мы можем воспользоваться **sapply.**

```{r}
sapply(arr[1:5], FUN = f)
```

Такой выход кажется более удобным. На самом деле lapply и sapply очень похожи. Об этом даже говорит справка:\
"*sapply(x, f, simplify = FALSE, USE.NAMES = FALSE) is the same as lapply(x, f*)".

Давайте подытожим полученное:

-   apply(X, MARGIN, FUN) - for matrixes (including dataframes) and arrays.

-   lapply(X, FUN) - for matrixes and arrays, returns list.

-   sapply(X, FUN, ...) - for matrixes and arrays, user-friendly version of lapply - returns vector or matrix.

## Анонимные функции

Вспомним функцию из предыдущей части:

```{r}
f = function(i) {
  return(i+1)
}
```

Можем ли мы записать ее короче?

```{r}
f = function(i) return(i+1)
f(1)
```

Вроде все работает. Но можно ли еще короче?

```{r}
f = function(i) i+1
f(1)
```

У нас получилось максимально коротко написать функцию, которая добавляет 1 к значению, которое идет на вход.

Тут надо добавить, что так писать функции не стоит. Во-первых, в некоторых языках, если вы явно не пропишете return, то ваша функция вам ничего не выдаст (например, в питоне в отличии от дружелюбного R). Во-вторых, функции даже в R стоит писать с return, поскольку мы вспоминаем важность наглядности и читаемости кода, и, чтобы ваш код мог прочитать кто-то другой (например, вы сами по прошествии нескольких дней), стоит ставить return явно с целью понять, что вообще функция выводит.

Но для анонимных функций return как раз писать не нужно (как в Питоне, где они называются лямбда-функциями, так и в Р). Так что такое анонимные функции? Это функции без имени, которые не хранятся как объекты в памяти и используются один раз.

Вспомним прошлый пример, когда мы хотели добавить к каждому элементу 1. Тогда мы писали так:

```{r}
sapply(arr, f)
```

Сейчас же мы можем написать так:

```{r}
sapply(arr, function(i) i + 1)
```

Пример посложнее - вычленяем числа из массива (здесь еще можно вспомнить про регулярки с прошлого сема):

```{r}
require(stringr)
subset = c('38.5A', '38', '42D', '33DDD', '405A')
sapply(subset, FUN = function(i){
      str_extract(i, '\\d.*\\d') %>%
    as.numeric()
    })
```

Или, например, разложение n! на простые числа:

```{r}
is.prime <- function(n) n == 2L || all(n %% 2L:ceiling(
  sqrt(n)) != 0)
decomp <- function(n) {
  primes <- which(sapply(1:n, is.prime))
  # использование sapply
  factors <- sapply(primes, function(p) {
    m <- floor(log(n, base = p))
    paste0(p, '^', sum(floor(n / (p ** (1:m)))))
    
  })
  paste(sub(pattern = '\\^1$', replacement = '', x = factors), collapse = ' * ')
}

decomp(15)
```

В примерах выше было использование анонимных функций, написанных как в одну строку, так и в несколько.

## Векторизация в R

R имеет много отличительных особенностей, как язык программирования. Один из них - вшитая\\ "фабричная"\\ встроенная (как удобнее) векторизация.\
Данная особенность позволяет нам не писать циклы, не "[генерировать списки](https://all-python.ru/osnovy/generator-spiska.html)", а использовать уже векторизированные функции (а их в R большинство, если не все), чтобы сразу получать ответ.\
Например, вместо `for (i in arr) is.na(i)` мы можем писать `is.na(arr)`, потому что is.na() - векторизированная функция.

Стоит понимать, откуда взялась эта векторизация. Это не так, что разработчики как при установке программы с торрента нажали галочку и язык стал векторизированным. Дело в том, что изначально весь код был написан таким образом, что даже оператор `+` (который, кстати, тоже функция и может быть изменен, что называется *overloading functions*)

```{r}
'+' = function(x,y) return(x*y)
print(5 + 3)
```

был написан на низком уровне (С или С++) с использованием тех же циклов и конструкций, что мы используем в R. Но посrольку низкий уровень работает быстрее, чем высокий, то очевидно, что и векторизация в R работает существенно быстрее, чем циклы (for, while, repeat). Можете [почитать](https://clarkfitzg.github.io/2017/11/06/are-apply-functions-faster-than-for-loops/) или сразу перейти к Main Point.

Распространенный миф также и в том, что \*apply() функции работают быстрее, чем циклы. На самом деле, это неправда. Давайте посмотрим, что сидит "под капотом" у apply:

```{r}
apply
```

Куча проверок, преобразований, создание новых объектов и тд, что, конечно же, важно, но тем не менее съедает время на реализацию кода. Можете об этом также прочесть в этом [комменте](https://habr.com/ru/post/475210/#comment_21401148).

Вывод: если есть возможность использовать векторизацию, используйте ее вместо sapply\\apply и уж тем более for\\while (что в общем-то практически одинаково медленно).

Например, тот же самый пример выше:

```{r}
sapply(arr, function(i) i + 1)
# или, что быстрее и гораздо компактнее
arr + 1
```

или же

```{r}
require(stringr)
subset = c('38.5A', '38', '42D', '33DDD', '405A')

sapply(subset, FUN = function(i){
      str_extract(i, '\\d.*\\d') %>%
    as.numeric()
    }) %>%
  print()

str_extract(subset, '\\d.*\\d') %>%
  print()
```

На это все. Спасибо за внимание!\
Если что-то непонятно, пишите.
